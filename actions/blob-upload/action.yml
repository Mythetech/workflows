name: 'Azure Blob Upload'
description: 'Uploads release artifacts to Azure Blob Storage'

inputs:
  app_name:
    description: 'Application name (e.g., Horizon)'
    required: true
  version:
    description: 'Version string for the release'
    required: true
  platform:
    description: 'Platform (Windows, macOS, Linux)'
    required: true
  release_dir:
    description: 'Directory containing the release artifacts'
    required: true
  storage_account:
    description: 'Azure Storage account name'
    required: true
  storage_container:
    description: 'Azure Storage container for versioned/latest releases'
    required: true
  releases_container:
    description: 'Azure Storage container for Velopack auto-update files'
    required: true
    default: 'releases'
  sas_token:
    description: 'Azure SAS token for authentication'
    required: true

outputs:
  versioned_path:
    description: 'The versioned blob path where release was uploaded'
    value: ${{ steps.upload.outputs.versioned_path }}
  latest_path:
    description: 'The latest blob path where release was uploaded'
    value: ${{ steps.upload.outputs.latest_path }}

runs:
  using: 'composite'
  steps:
    - name: Map platform to blob path
      id: platform_map
      shell: bash
      run: |
        case "${{ inputs.platform }}" in
          Windows)
            echo "BLOB_PLATFORM=windows" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=${{ inputs.app_name }}-Windows.zip" >> $GITHUB_OUTPUT
            ;;
          macOS)
            echo "BLOB_PLATFORM=macos" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=${{ inputs.app_name }}-MacOS.zip" >> $GITHUB_OUTPUT
            ;;
          Linux)
            echo "BLOB_PLATFORM=linux" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=${{ inputs.app_name }}-Linux.zip" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Prepare release zip file (Windows)
      if: inputs.platform == 'Windows'
      id: prepare_zip_windows
      shell: pwsh
      run: |
        $RELEASE_DIR = "${{ inputs.release_dir }}"
        $ZIP_NAME = "${{ steps.platform_map.outputs.ZIP_NAME }}"
        $ZIP_FILE = Join-Path $RELEASE_DIR $ZIP_NAME

        $SETUP_EXE = Get-ChildItem -Path $RELEASE_DIR -Filter "*Setup.exe" -File | Select-Object -First 1
        if (-not $SETUP_EXE) {
          $SETUP_EXE = Get-ChildItem -Path $RELEASE_DIR -Filter "*.msi" -File | Select-Object -First 1
        }

        if ($SETUP_EXE) {
          Write-Host "Found setup installer, creating zip: $($SETUP_EXE.FullName)"
          Compress-Archive -Path $SETUP_EXE.FullName -DestinationPath $ZIP_FILE -Force
        } else {
          $EXISTING_ZIP = Get-ChildItem -Path $RELEASE_DIR -Filter "*.zip" -File | Select-Object -First 1
          if ($EXISTING_ZIP) {
            Write-Host "No setup installer found, using existing zip"
            Copy-Item $EXISTING_ZIP.FullName $ZIP_FILE -Force
          } else {
            Write-Host "Error: No setup installer or zip file found in $RELEASE_DIR"
            Get-ChildItem -Path $RELEASE_DIR
            exit 1
          }
        }

        if (-not (Test-Path $ZIP_FILE)) {
          Write-Host "Error: Failed to create/find zip file at $ZIP_FILE"
          exit 1
        }

        "ZIP_FILE=$ZIP_FILE" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        Write-Host "Using zip file: $ZIP_FILE"
        Get-Item $ZIP_FILE | Format-List

    - name: Prepare release zip file (macOS/Linux)
      if: inputs.platform != 'Windows'
      id: prepare_zip_unix
      shell: bash
      run: |
        RELEASE_DIR="${{ inputs.release_dir }}"
        ZIP_NAME="${{ steps.platform_map.outputs.ZIP_NAME }}"
        ZIP_FILE="$RELEASE_DIR/$ZIP_NAME"

        if [ "${{ inputs.platform }}" = "macOS" ]; then
          PKG_INSTALLER=$(find "$RELEASE_DIR" -name "*.pkg" -type f | head -n 1)
          if [ -n "$PKG_INSTALLER" ]; then
            echo "Found .pkg installer, creating zip: $PKG_INSTALLER"
            cd "$RELEASE_DIR"
            zip -q "$ZIP_NAME" "$(basename "$PKG_INSTALLER")"
            cd - > /dev/null
          else
            EXISTING_ZIP=$(find "$RELEASE_DIR" -name "*Portable.zip" -type f | head -n 1)
            if [ -n "$EXISTING_ZIP" ]; then
              echo "No .pkg found, using Portable.zip"
              cp "$EXISTING_ZIP" "$ZIP_FILE"
            else
              echo "Error: No .pkg installer or Portable.zip found in $RELEASE_DIR"
              ls -la "$RELEASE_DIR"
              exit 1
            fi
          fi
        elif [ "${{ inputs.platform }}" = "Linux" ]; then
          APPIMAGE=$(find "$RELEASE_DIR" -name "*.AppImage" -type f | head -n 1)
          if [ -z "$APPIMAGE" ]; then
            echo "Error: No AppImage found in $RELEASE_DIR"
            ls -la "$RELEASE_DIR"
            exit 1
          fi
          echo "Creating zip from AppImage: $APPIMAGE"
          cd "$RELEASE_DIR"
          zip -q "$ZIP_NAME" "$(basename "$APPIMAGE")"
          cd - > /dev/null
        fi

        if [ ! -f "$ZIP_FILE" ]; then
          echo "Error: Failed to create/find zip file at $ZIP_FILE"
          exit 1
        fi

        echo "ZIP_FILE=$ZIP_FILE" >> $GITHUB_OUTPUT
        echo "Using zip file: $ZIP_FILE"
        ls -lh "$ZIP_FILE"

    - name: Upload to blob storage
      id: upload
      shell: bash
      run: |
        VERSION="${{ inputs.version }}"
        BLOB_PLATFORM="${{ steps.platform_map.outputs.BLOB_PLATFORM }}"
        ZIP_NAME="${{ steps.platform_map.outputs.ZIP_NAME }}"
        if [ "${{ inputs.platform }}" = "Windows" ]; then
          ZIP_FILE="${{ steps.prepare_zip_windows.outputs.ZIP_FILE }}"
        else
          ZIP_FILE="${{ steps.prepare_zip_unix.outputs.ZIP_FILE }}"
        fi

        # Upload to versioned path
        VERSIONED_PATH="$VERSION/$BLOB_PLATFORM/$ZIP_NAME"
        echo "Uploading to versioned path: $VERSIONED_PATH"
        az storage blob upload \
          --account-name "${{ inputs.storage_account }}" \
          --container-name "${{ inputs.storage_container }}" \
          --name "$VERSIONED_PATH" \
          --file "$ZIP_FILE" \
          --overwrite \
          --sas-token "${{ inputs.sas_token }}"

        # Upload to latest path
        LATEST_PATH="latest/$BLOB_PLATFORM/$ZIP_NAME"
        echo "Uploading to latest path: $LATEST_PATH"
        az storage blob upload \
          --account-name "${{ inputs.storage_account }}" \
          --container-name "${{ inputs.storage_container }}" \
          --name "$LATEST_PATH" \
          --file "$ZIP_FILE" \
          --overwrite \
          --sas-token "${{ inputs.sas_token }}"

        echo "versioned_path=$VERSIONED_PATH" >> $GITHUB_OUTPUT
        echo "latest_path=$LATEST_PATH" >> $GITHUB_OUTPUT

    - name: Upload Velopack releases for auto-update
      shell: bash
      run: |
        BLOB_PLATFORM="${{ steps.platform_map.outputs.BLOB_PLATFORM }}"
        RELEASE_DIR="${{ inputs.release_dir }}"
        APP_NAME_LOWER=$(echo "${{ inputs.app_name }}" | tr '[:upper:]' '[:lower:]')

        echo "Uploading Velopack release files from $RELEASE_DIR to releases/$APP_NAME_LOWER/$BLOB_PLATFORM"

        # Upload all files in the release directory (RELEASES, nupkg, etc.)
        for file in "$RELEASE_DIR"/*; do
          if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo "Uploading: $filename"
            az storage blob upload \
              --account-name "${{ inputs.storage_account }}" \
              --container-name "${{ inputs.releases_container }}" \
              --name "$APP_NAME_LOWER/$BLOB_PLATFORM/$filename" \
              --file "$file" \
              --overwrite \
              --sas-token "${{ inputs.sas_token }}"
          fi
        done
